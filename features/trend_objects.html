
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Trend objects &#8212; Wiggum 0.1 documentation</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../_static/alabaster.css" />
    <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  <div class="document">
    
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h3><a href="../index.html">Table of Contents</a></h3>
<p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../app_user_manual.html">User Manual for Wiggum App</a></li>
<li class="toctree-l1"><a class="reference internal" href="../API.html">API Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../app_structure.html">App Outline</a></li>
<li class="toctree-l1"><a class="reference internal" href="../JS_API.html">JS API Reference</a></li>
</ul>
<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../index.html">Documentation overview</a><ul>
  </ul></li>
</ul>
</div>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../_sources/features/trend_objects.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <div class="section" id="trend-objects">
<span id="id1"></span><h1>Trend objects<a class="headerlink" href="#trend-objects" title="Permalink to this headline">¶</a></h1>
<p>Trend objects are passed to <cite>LabeledDataFrame.get_subgroup_trends_1lev</cite> or another trend
computation method of <cite>LabeledDataFrame</cite>.  These functions store them in the
data structure in a property <cite>trend_list</cite>.</p>
<p>The design of the trend objects is to make mixing and matching of trends
components easy.</p>
<p>In <cite>trends.py</cite> we define complete trend objects that are available as
<cite>wg.&lt;trend_name&gt;</cite>. In the <cite>trend_components</cite> subpackage, we define the
component parts that are used to compose complete trend objects through
inheritence. We use Mixins in python to build complete trends. A complete,
usable trend object should be organized as follows.</p>
<p>There are three types of mixins and available Mixin classes are accessible in
<cite>wg.trend_components.baseTrendMixin_list</cite>,
<cite>wg.trend_components.varTypeMixin_list</cite>, and
<cite>wg.trend_components.trendCommputeMixin_list</cite></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="hll"><span class="k">class</span> <span class="nc">trend_example</span><span class="p">(</span><span class="n">trendCommputeMixin</span><span class="p">,</span><span class="n">varTypeMixin</span><span class="p">,</span> <span class="n">baseTrendMixin</span><span class="p">):</span>
</span>   <span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;my name&#39;</span> <span class="c1"># used in the trend_type column of result_df and by viz</span>
   <span class="c1"># other class variables as required by the Mixins or to overload</span>
</pre></div>
</div>
<p>This is how most of the code in <cite>trends.py</cite> is structured.  We include Mixins of
two basic types that allow for separating the computation of the trend and the
manipulation of the data into the various roles that the trend calculation
requires.  Currently there is only one <cite>baseTrendMixin</cite> class, that all must inherit:
<cite>trend</cite></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">trend</span><span class="p">():</span>
<span class="hll">    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">labeled_df</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
</span>       <span class="c1"># set trend_precompute to empty as an insntance property</span>
       <span class="c1"># if labeled_df is passed, call get_trend_vars</span>
       <span class="k">return</span> <span class="bp">self</span>
</pre></div>
</div>
<p>This could be overloaded to have a new initialization or a trend object with
additional instance properties.</p>
<p>The two mixin types are for setting how to compute the trend and its properties
and how to choose the variables.  These are separated because similar trends may
use the same variables (for example linear regression and linear correlation)
and a given trend computation may use different types of variables in ways that
make it meaningfully different though the computation is shared.</p>
<div class="section" id="get-trends-mixins">
<h2>Get Trends Mixins<a class="headerlink" href="#get-trends-mixins" title="Permalink to this headline">¶</a></h2>
<p>The trendCommputeMixin are found in <cite>trend_components/</cite> and have the following
signature. These pair the trend calcuation and the distance calculations, each
get Trend Mixin is compatible with only certain <cite>var_type_mixins</cite> based on the
required properties.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">trendCommputeMixin</span><span class="p">():</span>
<span class="hll">   <span class="k">def</span> <span class="nf">get_trends</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data_df</span><span class="p">,</span><span class="n">trend_col_name</span><span class="p">):</span>
</span>       <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">       Compute a trend, its quality and return a partial result_df</span>

<span class="sd">       Parameters</span>
<span class="sd">       ----------</span>
<span class="sd">       data_df : DataFrame or DataFrameGroupBy</span>
<span class="sd">           data to compute trends on, may be a whole, unmodified DataFrame or</span>
<span class="sd">       a grouped DataFrame as passed by LabeledDataFrame get trend functions</span>
<span class="sd">       trend_col_name : {&#39;subgroup_trend&#39;,&#39;agg_trend&#39;}</span>
<span class="sd">           which type of trend is to be computed</span>

<span class="sd">       Required properties</span>
<span class="sd">       --------------------</span>
<span class="sd">       name : string</span>
<span class="sd">               used in the trend_type column of result_df and by viz</span>
<span class="sd">       additional class or insntance properties that must be set in order to compmute this type</span>
<span class="sd">       of trend, these will be set by calling get_trend_vars</span>

<span class="sd">       Returns</span>
<span class="sd">       -------</span>
<span class="sd">       reg_df : DataFrame</span>
<span class="sd">           partial result_df, multiple can be merged together to form</span>
<span class="sd">           a complete result_df</span>
<span class="hll"><span class="sd">       &quot;&quot;&quot;</span>
</span>
   <span class="k">def</span> <span class="nf">get_distance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">row</span><span class="p">):</span>
       <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">       distance between the subgroup and aggregate trends for a row of a</span>
<span class="sd">       result_df that was computed by the same class&#39;s get_trends</span>

<span class="sd">       Parameters</span>
<span class="sd">       ----------</span>
<span class="sd">       row : pd.Series</span>
<span class="sd">           row of a result_df DataFrame</span>

<span class="sd">       Returns</span>
<span class="sd">       -------</span>
<span class="sd">       &lt;&gt;_dist : float</span>
<span class="sd">           distance between the subgroup_trend and agg_trend, compatible with</span>
<span class="sd">           assignment to a cell of a result_df</span>
<span class="sd">       &quot;&quot;&quot;</span>
</pre></div>
</div>
</div>
<div class="section" id="variable-type-mixins">
<h2>Variable Type Mixins<a class="headerlink" href="#variable-type-mixins" title="Permalink to this headline">¶</a></h2>
<p>The <cite>varTypeMixin`s define how to select variables for each required parameter
of the `get_trends</cite> functions. These are defined in
<cite>trend_components/base_getvars.py</cite></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">varTypeMixin</span><span class="p">():</span>
<span class="hll">   <span class="sd">&quot;&quot;&quot;</span>
</span><span class="sd">   mixin compatible with &lt;&gt; trends</span>
<span class="sd">   &quot;&quot;&quot;</span>
   <span class="n">class_property</span> <span class="o">=</span> <span class="n">value</span> <span class="c1"># set required parameters fro &lt;&gt; trends as</span>
                          <span class="c1"># class properties if appropriate</span>
   <span class="k">def</span> <span class="nf">get_trend_vars</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">labeled_df</span><span class="p">):</span>
       <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">       set required parameters for &lt;&gt; trends</span>

<span class="sd">       Parameters</span>
<span class="sd">       -----------</span>
<span class="sd">       labeled_df : LabeledDataFrame</span>
<span class="sd">           object to parse by variable types and roles, may be set to None as</span>
<span class="sd">           default or unused in custom overrides, but must be accepted for</span>
<span class="sd">           compatibility</span>

<span class="sd">       Returns</span>
<span class="sd">       --------</span>
<span class="sd">       Parameters that were set</span>
<span class="sd">       &quot;&quot;&quot;</span>
</pre></div>
</div>
<p>We present the underlying framework for detecting general trend changes such as Simpson’s paradox for exploratory analysis by a practitioner data scientist.</p>
<p>We generalize from the above framework of looking at binary trends of statistics of the data to considering more detailed trends between pairs of variables and trend-specific distances. We can capture the original cases in this framework by introducing a new $operatorname{trend}$ operator that is equivalent to the composition of the statistic of the data and the collapse to a binary value($operatorname{trend}_b$) in the prior formulation.</p>
<div class="math notranslate nohighlight">
\[S = \operatorname{dist}(\operatorname{trend}(X_1,X_2), \operatorname{trend}(X_1,X_2|X_3))\]</div>
<p>We consider two categories of trends: model-based and ranking. Ranking is the same as rankSP above and model-based is a generalization of the regression type classically studied.
For the model-based trends, we fit a model to the data ($x_1 = f(x_2; theta) $) and the trend is characterized by the model parameters ($ theta$).
We use some type model-fit to capture the strength of the trend and a distance based on the representation of the model.
% In linear trends we define the distance between the aggregate and partitions by the angle, normalized to [0,1].
For ranking trends, we compute a groupwise-statistic (partitioned by $x_2$) of the data ($x_1)$ and use it to order the groups.
The trend is characterized by the ordered list, strength is related to the separation of the groups and the distance to the similarity of lists.</p>
<p>We define modular trend objects that are passed to the batch trend computation methods of the LabeledDataFrame class that Wiggum provides for interacting with the data, metadata, and results.
The design of the trend objects is to make mixing and matching of trends components easy.
We provide a default set of complete trend objects and an interface to use the components to develop custom trends directly in addition to via overloading.
We use Python Mixins,  classes that define methods but no properties, to build complete trends.
This allows us to define subclasses that contain methods and mix and match them to create more flexible inheritance patterns.
A batch computation function computes the trend for all possible occurrences given the meta data provided by the user.</p>
<p>Wiggum has two basic kinds of trend Mixin classes that allow for separating the computation of the trend (trendComputeMixin) and the manipulation of the data into the various roles that the trend calculation requires (varTypeMixin).
% The two mixin types provide methods to compute the trend and its properties (trendComputeMixins)
% and how to determine the how to use variables in the trend computation from metadata.
This distinction provides several advantages.  First, it allows similar trends to use the same variables (for example linear regression and linear correlation) and share functions for determining columns from the metadata but different computations.
Second, it allows for a given trend computation may use different types of variables in ways that make it meaningfully different though the computation is shared, for example computing regression for continuous versus ordinal variables.
Third, the use of additional class properties enables further modification of the computation, for example ranking by mean or median or computing Pearson versus Spearman correlation.
We provide a single baseTrend that defines a constructor shared across all trend objects.</p>
<p>begin{minipage}[c]{0.95columnwidth}
begin{lstlisting}[language=Python,</p>
<blockquote>
<div><p>label={fig:exmapleTrend},
columns={fullflexible},
frame = single,
caption={Example of a trend class definition using the base class, texttt{trend}; trendComputeMixin, texttt{statRankTrend}; and varTypeMixin, texttt{weightedRank}. The class property texttt{my_stat} allows further customization of the texttt{statRankTrend}, for example we also have a median_rank_trend.}]</p>
</div></blockquote>
<dl>
<dt>class mean_rank_trend(statRankTrend,</dt><dd><blockquote>
<div><p>weightedRank,
trend):</p>
</div></blockquote>
<p>name = ‘rank_trend’ # required class property
# trend specific class variable
my_stat = lambda self,d,m,w : weighted_avg(d,m,w)</p>
</dd>
</dl>
<p>end{lstlisting}
end{minipage}</p>
<p>% TODO: make two column
input{tab_trendComputeMixin.tex}</p>
<p>The trendComputeMixins pair the trend calculation and the distance calculations, we provide 5, described in Table~ref{tab:trendcomputemixin}.
For the distance between linear trends, Wiggum uses a normalization of the angle between the lines fit the whole data set and the current partition.
The normalization step creates a distance in $[0,1]$ that is always positive valued.
This normalization makes the distance comparable to the 0/1 loss distance used in the binary detection setting.
We choose to make $d=1$ for a right angle  and $d=0$ for parallel lines, whether vertical or horizontal.</p>
<dl class="simple">
<dt>begin{align}</dt><dd><p>d = normangle(t_a,t_s) = frac{2}{pi} left(left|tan^{-1}(t_a) - tan^{-1}(t_s)right|% frac{pi}{2}right) label{eq:normangle}</p>
</dd>
</dl>
<p>end{align}
% []</p>
<p>where $%$ is the modulo operator and $t_a,t_s$ are slopes.
For multi-valued ranking trends, we rely on Kendall’s $tau$ based permutation distance for distance and strength.
The distance is the Kendall’s Tau distance between the aggregate and subgroup trend lists.
The strength is the Kendall’s tau similarity between the element-wise sorted list and the trend-sorted list.</p>
<dl class="simple">
<dt>begin{align}</dt><dd><p>tau(a,b) &amp;= frac{P - Q}{sqrt{(P + Q + T)(P+Q + U)}}</p>
</dd>
</dl>
<p>end{align}</p>
<p>where $P$ is the number of concordant pairs, $Q$ is the number of discordant pairs, $T$ is the number of ties only in $a$  and U is the number of pairs only in $b$.
For example, in the case of two groups if $t_a = [M,F]$ and $t_s = [F,M]$, we get $P=0$, $Q=2$, $T=0$, $U=0$ and find $tau = - 1$ and the distance is $1$, so it’s the same as the 0/1 loss on the comparison.
In the case of three levels of $x_2$, however is the advantage, for $t_a = [B,H,W]$ and $t_s = [B,W,H]$, we get a distance of .333, matching lists are always 0 and complete reversal is always 1.
To extend this to compute trend strength, we sort the $x_2$ column of the dataset(or partition) by $x_1$ to create $ell_a$ and repeat each element of $t_x$ in accordance with its representation in the data so that $ell_b$ is the same length as $ell_a$, then the strength is $|tau(ell_a,ell_b)|$.
This is analogous to the use of the magnitude of Pearson correlation coefficient for strength of linear regression trends.</p>
<p>The <a href="#id2"><span class="problematic" id="id3">`</span></a>varTypeMixin`s define how to select variables for each required parameter of the trend calculation functions, that is which variables form the data set take on the roles of $x_1$, $x_2$, and $w$.
These functions use the meta data from the user that defines a variable type(binary, categorical, continuous, ordinal) and a role (trend or group-by). Variable usage under default settings for the two categories of trends(ranking and continuous) are defined in Table~ref{tab:variableuse}.</p>
<p>input{tab_variable_role.tex}</p>
<p>subsection{Ranking and Detection}</p>
<p>In order to present the results, we need to order them, for sequential assessment by the analyst.
The trend computation step returns a result table as shown in Figure~ref{fig:exp_resulttable} .
Wiggum ranks each occurrence, represented by a row in the table, based on both occurrence-specific scores and view aggregate scores.
In Wiggum-app, a user can rank by choosing the column to aggregate and the aggregation method(sum, mean, max, min) to compute a view score.
We consider both view aggregate scores and occurrence specific methods of ranking and produce combination statistics that allow for integrated ranking.
Using the Wiggum package in a scientific computing environment, weighted sums of view or occurrence or combinations of the two can also be added to the result table for ranking or filtering.</p>
<p>We compare ranking by count of subgroups for variable pairs; count of subgroup levels, and the severity of the trend change, though the detection is anything that is a reversal, we consider that it can be minor (small distance and/or weak trend).
% We also explore how weighting of these impacts the ordering.</p>
<p>% TODO: maybe not in this paper
% We compare the rankings with a correlation matrix; since the ranks are all integers, this is a suitable way to compare how the variables compare.</p>
</div>
</div>


          </div>
          
        </div>
      </div>
    <div class="clearer"></div>
  </div>
    <div class="footer">
      &copy;2019, Chenguang Xu, Sarah M Brown, Christan E Grant.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 4.2.0</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.11</a>
      
      |
      <a href="../_sources/features/trend_objects.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>