import pandas as pd
import numpy as np
import scipy.stats as stats
import itertools as itert


def add_slope_sp(data_df, result_df):
    """
    compute the slope for each entry of an sp result using the data

    Parameters
    -----------
    data_df : pandas dataframe
        data to be used for computing the slopes
    result_df : pandas dataframe (optional)
        results generated by detect_simpsons_paradox applied to data_df

    Returns
    --------
    a copy of result_df with subgroup_slope and all_slop columns adeed

    """
    #compute whole data slopes
    # iterate rows of result df
    new_res = result_df
    slope_list = []
    for i,row in result_df.iterrows():
        # extract data for that row
        data_rows = data_df.loc[data_df[row['groupbyAttr']]==row['subgroup']]
        attr1data = data_rows[row['attr1']]
        attr2data = data_rows[row['attr2']]
        # comput lin regress for data according to that row
        slope, intercept, r_value, p_value, std_err = stats.linregress(attr1data,attr2data)
        slope_list.append(slope)

    new_res['subgroup_slope'] = slope_list
    return new_res

def compute_slope_all(data_df,data_cols):
    """
    compute the slope of all of the overall (no conditioning) for each pair of
    of columns listed in data_cols

    Parameters
    -----------
    data_df : pandas DataFrame
        dataset to compute the slope of the trend of eac pair
    data_cols : list of strings
        names of columns to compute slope of (ie the continuous vars)

    Returns
    --------
    all_slopes_df : pandas DataFrame
        a dataframe with columns 'attr1', 'attr2' and 'all_slope' and one row
        per pair of variables in data_cols
    """
    all_slopes = []
    for a,b in itert.combinations(data_cols,2):
    # compute each slope
        slope, intercept, r_value, p_value, std_err = stats.linregress(data_df[a],data_df[b])
        all_slopes.append([a,b,slope])

    #save as df
    all_slopes_df = pd.DataFrame(data = all_slopes, columns = ['attr1','attr2','all_slope'])
    return all_slopes_df

def compute_angle(row):
    """
    compute angle between the overall ('all_slope') and subgroup
    ('subgroup_slope') slopes for each row.
    """
    theta_sub = np.arctan(row['subgroup_slope'])
    theta_all = np.arctan(row['all_slope'])
    return np.rad2deg(theta_all - theta_sub)


def mark_designed_rows(result_df,design_list_tuples):
    """
    add a colomn to a result_df that marks which are designed

    Parameters
    -----------
    result_df : DataFrame
        generaed from detect_simpsons_paradox
    design_list_tuples : list of tuples
        a list of the attributes with designed in SP. in the form
        [(attr1,attr2,groupbyAttr),...]

    Returns
    --------
    result_df : DataFrame
        with added column 'designed' with boolean values
    """

    des = []
    # create a list of the rows with the designed in cases
    for i,r in enumerate(result_df[['attr1','attr2','groupbyAttr']].values):
        if tuple(r) in design_list_tuples:
            des.append(i)

    # add a column of all False values
    result_df['designed'] = False
    # change the designed ones to true
    result_df.loc[des,'designed'] = True

    return result_df
